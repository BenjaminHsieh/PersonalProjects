#     if (all(subset(df.lb.sdtm.v0, (Unique.Subject.Identifier == cursubjectid()) & (Category.for.Lab.Test == input$t2.cat.lab), select=Subcategory.for.Lab.Test)=="")) {
#       return()
#     }
#     # Get selected category
#     selectizeInput('t2.sub.lab', 'Subcategory', choices = sub.list[input$t2.cat.lab], multiple = TRUE)
#   })
#
# Lab name, dynamic to Category and Subject
output$choose.lab <- renderUI({
category <- input$t2.cat.lab
subject <- cursubjectid()
thisdata <- filter(df.lb.sdtm.v0, Unique.Subject.Identifier %in% subject, Category.for.Lab.Test %in% category)
labtest <- levels(droplevels(thisdata$Lab.Test.or.Examination.Name))
selectizeInput(inputId  = "t2.lab.testname",
label    = h4("Lab Test or Name"),
choices  = labtest,
multiple = T,
options  = list(placeholder = 'Please select test(s)')
)
})
#-------------------------------------------------------------------------------------------------#
# PLOTTING
#-------------------------------------------------------------------------------------------------#
# Add plot line
plotlines <- reactive({
if (input$t2showline==TRUE) {
return(geom_line(aes(colour = Lab.Test.or.Examination.Name), size = 1))
} else {
return(NULL)
}
})
# Add Reference Lines
reflines <- reactive({
if (input$t2showrefline == TRUE) {
thisdata <- t2.curdata()
ggout <- list(
geom_hline(data = thisdata, aes(yintercept = Reference.Range.Upper.Limit.Std.Units, colour = Lab.Test.or.Examination.Name), linetype = 2),
geom_hline(data = thisdata, aes(yintercept = Reference.Range.Lower.Limit.Std.Units, colour = Lab.Test.or.Examination.Name), linetype = 2)
)
return(ggout)
} else {
return(NULL)
}
})
# Create ggplot object
plot.it <- reactive({
# We plot it with a call to current data function t2.curdata()
# get current dataset
data.in <- t2.curdata()
# if subset data has no numeric results (i.e. categorical variable results), then return
if (all(is.na(data.in$Numeric.Result.Finding.in.Standard.Units))) {
return()
} else {
plot.out<-ggplot(data = data.in, aes(x = Study.Day.of.Specimen.Collection,
y = Numeric.Result.Finding.in.Standard.Units,
group = Lab.Test.or.Examination.Name)) +
geom_point(colour = "grey50", size = 4, na.rm = T) +
geom_point(aes(colour = factor(Lab.Test.or.Examination.Name)), na.rm = T) +
plotlines() +
reflines() +
theme_set(theme_gray(16)) +
theme(axis.title.y    = element_text(size = rel(0.7), angle = 90),
axis.title.x    = element_text(size = rel(0.7)),
legend.position = "bottom", legend.text = element_text(size = 11)) +
guides(colour = guide_legend(title = NULL, ncol = 3)) +
ylab("Standard Units")+
xlab("Study Day")
return(plot.out)
}
})
# Render Plot
output$plot <- renderPlot({
plot.it()
})
#-------------------------------------------------------------------------------------------------#
# Interactive Plot
# Dynamically changing the plot
output$plotui <- renderUI({
plotOutput("plot",
height   = 800,
click    = "plot.click",
dblclick = dblclickOpts(
id     = "plot.dblclick",
delay  = input$dblclick.delay
),
brush    = brushOpts(
id         = "plot.brush",
delay      = input$brush.delay,
delayType  = input$brush.policy,
direction  = input$brush.dir,
resetOnNew = input$brush.reset
)
)
})
# Reactive Function for brushing
t2.getbrushset <- reactive({
dat <- t2.curdata()
brush.data <- brushedPoints(dat, input$plot.brush)
# Replace NAs with empty string to ensure each entry has a value and prevents corruption
brush.data[is.na(brush.data)] <- ""
brush.data <- brush.data[complete.cases(brush.data),]
return(brush.data)
})
# Reactive Function for Hovering
output$hoverpoints.text <- renderPrint({
cat("Info from Hover:\n")
if (is.null(input$plot.hover)) {
return()
}
hoverinfo <- input$plot.hover
dat <- isolate({t2.curdata()})
xval <- hoverinfo$x
yval <- hoverinfo$y
dist <- sqrt((xval - dat$Study.Day.of.Specimen.Collection) ^ 2 + (yval - dat$Numeric.Result.Finding.in.Standard.Units) ^ 2)
dfinfo <- select(dat, Unique.Subject.Identifier, Visit.Number, Numeric.Result.Finding.in.Standard.Units)
dfinfo <- rename(dfinfo, Numeric.Result = Numeric.Result.Finding.in.Standard.Units)
hoverdata <- dfinfo[which(dist < 2),]
if (all(is.na(hoverdata))) {
return(NULL)
} else {
return(hoverdata)
}
})
#-------------------------------------------------------------------------------------------------#
# Zoom Plot
# Reactive function that takes the range of zoomed plot
ranges <- reactiveValues(x = NULL, y = NULL)
# Dynamic Plot (hovering)
output$zoomplotui <- renderUI({
plotOutput("zoom.plot",
hover    = hoverOpts(
id          = "plot.hover",
delay       = input$hover.delay,
delayType   = input$hover.policy,
nullOutside = input$hover.null.outside
),
height = 600)
})
# Render Plot
output$zoom.plot <- renderPlot({
if (is.null(plot.it())) {
return()
}
plot.it() +
coord_cartesian(xlim = ranges$x, ylim = ranges$y) +
theme(legend.position = "none")
})
# When a double-click happens, check if there's a brush on the plot.
# If so, zoom to the brush bounds; if not, reset the zoom.
observe({
brush <- input$plot.brush
if (!is.null(brush)) {
ranges$x <- c(brush$xmin, brush$xmax)
ranges$y <- c(brush$ymin, brush$ymax)
} else {
ranges$x <- NULL
ranges$y <- NULL
}
})
#--------------------------------------------------------------------------------------------------#
# Hide/Show Plot Options
# Double Click Options
output$plotoption1 <- renderUI({
if (input$plotoptions == FALSE) {
return()
} else {
div(class = "option-group",
div(class = "option-header", "Double-click"),
sliderInput(inputId = "dblclick.delay",
label   = "Delay",
min     = 100,
max     = 1000,
value   = 400,
step    = 100)
)
}
})
# Hover Options
output$plotoption2 <- renderUI({
if (input$plotoptions == FALSE) {
return()
} else {
div(class = "option-group",
div(class = "option-header", "Hover"),
radioButtons("hover.policy", "Input rate policy",
c("debounce", "throttle"), inline = TRUE),
sliderInput(inputId = "hover.delay",
label   = "Delay",
min     = 100,
max     = 1000,
value   = 200,
step    = 100),
checkboxInput(inputId = "hover.null.outside",
label   = "NULL when outside",
value   = TRUE)
)
}
})
# Brush Options
output$plotoption3 <- renderUI({
if (input$plotoptions == FALSE) {
return()
} else {
div(class = "option-group",
div(class = "option-header", "Brush"),
radioButtons(inputId = "brush.dir",
label   = "Direction(s)",
choices = c("xy", "x", "y"),
inline  = TRUE),
radioButtons(inputId = "brush.policy",
label   = "Input rate policy",
choices = c("debounce", "throttle"),
inline  = TRUE),
sliderInput(inputId = "brush.delay",
label   = "Delay",
min     = 100,
max     = 1000,
value   = 200,
step    = 100),
checkboxInput(inputId = "brush.reset",
label   = "Reset on new image")
)
}
})
#-------------------------------------------------------------------------------------------------#
# Tables
#-------------------------------------------------------------------------------------------------#
# Render Table from Subsetting
output$table.subset <- renderDataTable({
datatable(data = t2.curdata(),
options = list(scrollX = TRUE)
)
})
# Render Table from Brushing
output$table.brushed <- renderDataTable({
datatable(data = t2.getbrushset(),
options = list(scrollX = TRUE)
)
})
#-------------------------------------------------------------------------------------------------#
# Download
#-------------------------------------------------------------------------------------------------#
# Download Plot
output$downloadplot <- downloadHandler(
# save ggplot as pdf
filename <- paste("myplot", Sys.Date(), ".pdf", sep = ''),
content  <- function(file) {
device <- function(..., width, height) {
pdf(..., width = width, height = height)
}
ggsave(file, plot = plot.it(), device = device)
}
)
# Download table
output$downloadtable <- downloadHandler(
# Write as cvs/txt file
# Only works in browser
filename <- function(){
paste("brushtable", input$select.download.type, sep = ".")
},
content <- function(file) {
sep <- switch(input$select.download.type,
"csv" = ",",
"txt" = "\t")
write.table(t2.getbrushset(), file = file, sep = sep, row.names = FALSE)
}
)
#-------------------------------------------------------------------------------------------------#
# Tab 3
#-------------------------------------------------------------------------------------------------#
#-------------------------------------------------------------------------------------------------#
# PLOTTING
#-------------------------------------------------------------------------------------------------#
# Get current data
t3.curdata <- reactive({
getDataset(df = df.lb.sdtm.v1,
tab.num = 3,
test = input$t3.choose.lab.testname
)
})
#-------------------------------------------------------------------------------------------------#
# Reactive Functions for brushing, see tab 2 for details
# [Possible IMPLMENTATON: To get rid of delay when checkboxes are changed, have  "isolate" each checkbox, so use 4 checkboxinput instead of a checkbox group]
# Scatter/line plot
t3.getbrushset.scat <- reactive({
dat <- t3.curdata()
brush.data <- brushedPoints(dat, input$t3scat.brush)
brush.data[is.na(brush.data)] <- ""
brush.data <- brush.data[complete.cases(brush.data),]
return(brush.data)
})
# Box plot
t3.getbrushset.hist <- reactive({
dat <- t3.curdata()
brush.data <- brushedPoints(dat, input$t3hist.brush)
brush.data[is.na(brush.data)] <- ""
brush.data <- brush.data[complete.cases(brush.data),]
return(brush.data)
})
# Histogram
t3.getbrushset.box <- reactive({
dat <- t3.curdata()
brush.data <- brushedPoints(dat, input$t3box.brush)
brush.data[is.na(brush.data)] <- ""
brush.data <- brush.data[complete.cases(brush.data),]
return(brush.data)
})
#-------------------------------------------------------------------------------------------------#
# Get gg object for plots
getChangeFromBaseLine.gg <- reactive({
# If no lab test chosen, return to avoid error
# If no numeric values under selected factor, return string in console
# Else return ggplot object
if (is.null(input$t3.choose.lab.testname)) {
return()
}
gg.df <- t3.curdata()
if (all(is.na(gg.df$Change.From.Baseline.Numeric.Result))) {
return("No Numeric Values")
} else {
t3.ggout <- ggplot(data = gg.df)
return(t3.ggout)
}
})
#-------------------------------------------------------------------------------------------------#
# Plot it
# Scatter ggplot
output$scatgout <- renderPlot({
# If scat is checked in sidePanel (inputId=cfb.plot.type) & call to getChangeFromBaseLine.gg()
# does not return a character object, then returns a scatter plot with:
#   1. x = Sequence.Number
#   2. y = Change.From.Baseline.Numeric.Result
#   3. colour = by Unique.Subject.Identifier
#   4. no legend
#   5. zoom coordinates
if (!(any(input$cfbPlotType %in% "scat"))) {
return()
}
obj.out<-getChangeFromBaseLine.gg()
if (is.character(obj.out)) {
print(obj.out)
} else {
obj.out +
geom_point(aes(x = Sequence.Number,
y = Change.From.Baseline.Numeric.Result,
colour = factor(Unique.Subject.Identifier))) +
t3.line() +
theme(legend.position = "none") +
coord_cartesian(xlim = t3scat.range$x, ylim = t3scat.range$y)+
ylab("Change From Baseline") +
xlab("Sequence Number")
}
})
# Scatter Rchart Plo, uses the NVD3.js library
output$scatcout <- renderChart({
# If scat is checked in sidePanel (inputId=cfbPlotType) & call to getChangeFromBaseLine.gg()
# does not return a character object, then returns a scatter plot with:
#   1. x = Sequence.Number
#   2. y = Change.From.Baseline.Numeric.Result
#   3. colour = by Unique.Subject.Identifier
#   4. no legend
#   5. zoom coordinates
if (!(any(input$cfbPlotType %in% "scat"))) {
return()
} else {
dftemp <- t3.curdata()
names(dftemp) <- gsub("\\.", "", names(dftemp))
chartout<-nPlot(ChangeFromBaselineNumericResult~SequenceNumber, data = dftemp, group = "UniqueSubjectIdentifier", type = "scatterChart")
chartout$chart(tooltipContent = "#!function(key, x, y, e, graph){ return key + ' | ' + e.point.VisitNumber} !#",
showLegend = FALSE
)
chartout$xAxis(axisLabel = "Sequence Number")
chartout$yAxis(axisLabel = "Change from Baseline")
chartout$set(legendPosition = "none")
chartout$addParams(dom = "scatcout")
return(chartout)
}
})
# Line Plot: a reactive function that feeds into scatter ggplot when checkbox is true
t3.line <- reactive({
# If line is checked in sidePanel (inputId=cfbPlotType) & call to getChangeFromBaseLine.gg()
# does not return a character object, then returns a line plot with:
#   1. x = Sequence.Number
#   2. y = Change.From.Baseline.Numeric.Result
#   3. colour = by Unique.Subject.Identifier
#   4. no legend
#   5. zoom coordinates
if (!(any(input$cfbPlotType %in% "line"))) {
return()
}
geom_line(aes(x = Sequence.Number,
y = Change.From.Baseline.Numeric.Result,
colour = factor(Unique.Subject.Identifier)))
})
# Boxplot
output$box.out <- renderPlot({
# If box is checked in sidePanel (inputId=cfbPlotType) & call to getChangeFromBaseLine.gg()
# does not return a character object, then returns a box plot with:
#   1. x = Lab.Test.or.Examination.Name
#   2. y = Change.From.Baseline.Numeric.Result
#   3. colour/each boxplot corresponds to individual patients (Unique.Subject.Identifier)
#   4. no legend
#   5. zoom coordinates
if (!(any(input$cfbPlotType %in% "box"))) {
return()
}
obj.out <- getChangeFromBaseLine.gg()
if (is.character(obj.out)) {
print(obj.out)
} else {
obj.out +
geom_boxplot(aes(x    = Lab.Test.or.Examination.Name,
y    = Change.From.Baseline.Numeric.Result,
fill = (Unique.Subject.Identifier))) +
theme(legend.position = "none") +
coord_cartesian(xlim = t3box.range$x, ylim = t3box.range$y)+
ylab("Change from Baseline")+
xlab("Lab Test or Examination Name by Subject")
}
})
# Histogram
output$hist.out<- renderPlot({
# If hist is checked in sidePanel (inputId=cfbPlotType) & call to getChangeFromBaseLine.gg()
# does not return a character object, then returns a histogram with:
#   1. x = Change.From.Baseline.Numeric.Result
#   2. y = Counts (grouped by numeric result)
#   3. colour = corresponds to individual patients (Unique.Subject.Identifier)
#   4. no legend
#   5. zoom coordinates
if (!(any(input$cfbPlotType %in% "hist"))) {
return()
}
obj.out <- getChangeFromBaseLine.gg()
if (is.character(obj.out)) {
print(obj.out)
} else {
obj.out +
geom_histogram(aes(x    = Change.From.Baseline.Numeric.Result,
fill = Unique.Subject.Identifier)) +
theme(legend.position = "none") +
coord_cartesian(xlim = t3hist.range$x, ylim = t3hist.range$y)+
ylab("Count")+
xlab("Change From Baseline by Subject")
}
})
#------------------------------------------Zoom Plot----------------------------------------#
# Initialize ranges as reactive values
t3scat.range <- reactiveValues(x = NULL, y = NULL)
t3line.range <- reactiveValues(x = NULL, y = NULL)
t3box.range  <- reactiveValues(x = NULL, y = NULL)
t3hist.range <- reactiveValues(x = NULL, y = NULL)
# Set ranges on double click
# Scatter
observeEvent(input$t3scat.dblclick, {
brush <- input$t3scat.brush
if (!is.null(brush)) {
t3scat.range$x <- c(brush$xmin, brush$xmax)
t3scat.range$y <- c(brush$ymin, brush$ymax)
} else {
t3scat.range$x <- NULL
t3scat.range$y <- NULL
}
})
# Boxplot
observeEvent(input$t3box.dblclick, {
brush <- input$t3box.brush
if (!is.null(brush)) {
t3box.range$x <- c(brush$xmin, brush$xmax)
t3box.range$y <- c(brush$ymin, brush$ymax)
} else {
t3box.range$x <- NULL
t3box.range$y <- NULL
}
})
# Histogram
observeEvent(input$t3hist.dblclick, {
brush <- input$t3hist.brush
if (!is.null(brush)) {
t3hist.range$x <- c(brush$xmin, brush$xmax)
t3hist.range$y <- c(brush$ymin, brush$ymax)
} else {
t3hist.range$x <- NULL
t3hist.range$y <- NULL
}
})
#-------------------------------------------------------------------------------------------------#
# Show Tables
#-------------------------------------------------------------------------------------------------#
# Show brushed points in a table for scatterplot and lineplot as
# functionality does not work with histogram and boxplot.
# [In future, have to implement rCharts for a better user-interactive plots that includes histogram and boxplot]
# Scatter
output$t3.scatsubset <- renderDataTable({
datatable(data = t3.getbrushset.scat(),
options = list(scrollX = TRUE)
)
})
#------------------------------------------Outlier Detection--------------------------------------#
# Outlier detection [To be implemented]
output$outlier.test.type <- renderUI({
# Return if no lab.test choose OR scatterplot is not selected
if (!any(input$cfbPlotType %in% "scat") || is.null(input$t3.choose.lab.testname)) {
return()
}
# [OTHER CODE HERE]
})
}
#==================================================================================================#
# Run App
#==================================================================================================#
shinyApp(ui = ui, server = server)
quit()
